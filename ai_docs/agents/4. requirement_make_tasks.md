# Requirement Make Tasks Agent

Transform a validated requirement and its solution design into actionable development tasks.

## Purpose

Break down a solution design into granular, implementable tasks that developers can execute following the project's development workflow.

## Prerequisites

Before creating tasks:
1. Requirement must be validated (Agent 2)
2. Solution design must be complete (Agent 3)

## Input

- Path to the feature folder containing `requirements.md` and `design.md`

## Instructions

### Step 1: Read Documentation (MANDATORY)

**You MUST read these documents before creating any tasks:**

1. **FIRST: Read the solution design document** (`design.md`) - This is the source of truth for:
   - File paths and structure
   - Entity designs and methods
   - Value object implementations
   - Repository interface methods
   - Database schema
   - Testing strategy

2. **SECOND: Read the requirement document** (`requirements.md`) - For:
   - Acceptance criteria
   - Scope boundaries
   - What's included/excluded

3. **THIRD: Read architecture docs:**
   - `/ai_docs/architecture/architecture.md` - DDD structure

**CRITICAL:** Tasks must reflect EXACTLY what is specified in the design document. Do not add methods or features not in the design without explicit justification.

### Step 2: Extract Implementation Items

From the solution design, extract:
- Domain entities, value objects, enums
- Repository interfaces and implementations
- SQLAlchemy models
- Migrations
- Commands and queries (if in scope)
- HTTP layer components (if in scope)
- Tests
- DI container registrations

### Step 3: Apply Development Phases

Tasks MUST follow this order (Domain-First Development):

```
PHASE 1: Domain Layer (Framework-Agnostic)
  ├── Enums (no dependencies)
  ├── Value Objects (no dependencies)
  ├── Entities (depend on enums + value objects)
  └── Repository Interfaces (depend on entities)

PHASE 2: Infrastructure Layer
  ├── Migrations (Alembic)
  ├── SQLAlchemy Models
  └── Repository Implementations

PHASE 3: Application Layer (if in scope)
  ├── Commands + Handlers
  ├── Queries + Handlers
  └── DTOs

PHASE 4: HTTP Layer (if in scope)
  ├── Schemas (Pydantic)
  ├── Controllers
  ├── Routers
  └── Mappers

PHASE 5: Tests
  ├── Unit Tests (Domain)
  └── Integration Tests (Repositories)

PHASE 6: Configuration
  └── DI Container registration
```

**Why Domain First?**
- Domain layer has zero external dependencies
- Can be developed and tested without database
- Follows DDD principles (domain is the core)
- Migrations depend on understanding the domain model

### Step 4: Create Tasks

For each implementation item from the design, create a task with:
- Clear title matching design document
- File path exactly as specified in design
- Description
- Acceptance criteria from design
- Dependencies on other tasks
- Estimated complexity (S/M/L)
- Phase reference

### Step 5: Order Tasks

Tasks must be ordered by:
1. Phase (Domain → Infrastructure → Application → HTTP → Tests → Config)
2. Dependencies (dependent tasks after their dependencies)
3. Parallelization opportunities (identify batches)

## Output Format

Save to: `[feature-folder]/tasks.md`

```markdown
# Implementation Tasks: [Feature Name]

**Requirement:** [link to requirements.md]
**Solution Design:** [link to design.md]
**Created:** [date]
**Total Tasks:** [count]
**Estimated Complexity:** [S/M/L/XL]

## Summary

| Phase | Tasks | Complexity |
|-------|-------|------------|
| Domain - Enums | X | S |
| Domain - Value Objects | X | S-M |
| Domain - Entities | X | M |
| Domain - Interfaces | X | S |
| Infrastructure - Migrations | X | S |
| Infrastructure - Models | X | S |
| Infrastructure - Repositories | X | M |
| Tests | X | M |
| DI Container | X | S |

---

## Phase 1: Domain Layer - Enums

### TASK-001: Create [Entity]Status Enum

**Phase:** Domain
**Complexity:** S
**Dependencies:** None

**Description:**
Create the status enum for [Entity].

**File:** `src/[bc]/[domain]/domain/enums/[entity]_status.py`

**Implementation:**
```python
from enum import Enum

class [Entity]Status(str, Enum):
    VALUE_1 = "value_1"
    VALUE_2 = "value_2"
```

**Acceptance Criteria:**
- [ ] Enum with all values from design
- [ ] Inherits from str, Enum for JSON serialization

---

## Phase 1: Domain Layer - Value Objects

### TASK-002: Create [Entity]Id Value Object

**Phase:** Domain
**Complexity:** S
**Dependencies:** None

**Description:**
Create ULID-based ID value object.

**File:** `src/[bc]/[domain]/domain/value_objects/[entity]_id.py`

**Acceptance Criteria:**
- [ ] Immutable (frozen dataclass)
- [ ] generate() class method
- [ ] from_string() class method
- [ ] ULID validation

---

## Phase 1: Domain Layer - Entities

### TASK-003: Create [Entity] Entity

**Phase:** Domain
**Complexity:** M
**Dependencies:** TASK-001, TASK-002

**Description:**
Create entity with state machine methods as defined in design.

**File:** `src/[bc]/[domain]/domain/entities/[entity].py`

**Acceptance Criteria:**
- [ ] All properties from design
- [ ] Factory methods from design
- [ ] State transition methods from design
- [ ] Dataclass implementation

---

## Phase 1: Domain Layer - Repository Interfaces

### TASK-004: Create [Entity]RepositoryInterface

**Phase:** Domain
**Complexity:** S
**Dependencies:** TASK-003

**Description:**
Create repository interface (port) in domain layer.

**File:** `src/[bc]/[domain]/domain/interfaces/[entity]_repository_interface.py`

**Acceptance Criteria:**
- [ ] ABC interface
- [ ] Methods exactly as specified in design
- [ ] Uses domain value objects in signatures

---

## Phase 2: Infrastructure Layer - Migrations

### TASK-005: Create [table] Migration

**Phase:** Infrastructure
**Complexity:** S
**Dependencies:** TASK-003

**Description:**
Create Alembic migration for [table] table.

**File:** `alembic/versions/XXX_create_[table]_table.py`

**Schema:** (from design document)
```sql
-- Copy exact schema from design
```

**Acceptance Criteria:**
- [ ] All columns from design
- [ ] Indexes from design
- [ ] Foreign keys from design
- [ ] Reversible (downgrade method)

---

## Phase 2: Infrastructure Layer - Models

### TASK-006: Create [Entity]Model

**Phase:** Infrastructure
**Complexity:** S
**Dependencies:** TASK-005

**Description:**
Create SQLAlchemy model.

**File:** `src/[bc]/[domain]/infrastructure/models/[entity]_model.py`

**Acceptance Criteria:**
- [ ] All columns mapped
- [ ] Table name set
- [ ] Indexes defined
- [ ] Relationships (if any)

---

## Phase 2: Infrastructure Layer - Repositories

### TASK-007: Create [Entity]Repository

**Phase:** Infrastructure
**Complexity:** M
**Dependencies:** TASK-004, TASK-006

**Description:**
Create repository implementation (adapter).

**File:** `src/[bc]/[domain]/infrastructure/repositories/[entity]_repository.py`

**Acceptance Criteria:**
- [ ] Implements [Entity]RepositoryInterface
- [ ] Model-to-Entity conversion
- [ ] Entity-to-Model conversion
- [ ] All interface methods implemented

---

## Phase 3: Tests

### TASK-008: Unit Tests - Value Objects

**Phase:** Tests
**Complexity:** M
**Dependencies:** Value object tasks

**Description:**
Create unit tests for all value objects.

**Files:** `tests/unit/[bc]/[domain]/test_*.py`

**Acceptance Criteria:**
- [ ] Valid creation tests
- [ ] Invalid input rejection tests
- [ ] Edge cases
- [ ] 95%+ coverage

---

### TASK-009: Unit Tests - Entities

**Phase:** Tests
**Complexity:** M
**Dependencies:** Entity tasks

**Description:**
Create unit tests for all entities.

**Acceptance Criteria:**
- [ ] Factory method tests
- [ ] State transition tests (valid and invalid)
- [ ] 95%+ coverage

---

### TASK-010: Integration Tests - Repositories

**Phase:** Tests
**Complexity:** M
**Dependencies:** Repository tasks

**Description:**
Create integration tests for repositories.

**Files:** `tests/integration/[bc]/[domain]/test_*_repository.py`

**Acceptance Criteria:**
- [ ] All repository methods tested
- [ ] Uses test database
- [ ] Transaction rollback
- [ ] 80%+ coverage

---

## Phase 4: DI Container

### TASK-011: Register in DI Container

**Phase:** Configuration
**Complexity:** S
**Dependencies:** All repository tasks

**Description:**
Register repositories in dependency injection container.

**File:** `core/containers/[bc]_container.py`

**Acceptance Criteria:**
- [ ] All repositories registered
- [ ] Proper scoping (singleton/factory)

---

## Dependency Graph

```
[Include ASCII diagram showing task dependencies]
```

## Execution Order

**Batch 1 (Parallel):** [list tasks that can run in parallel]
**Batch 2 (Parallel):** [list tasks]
...

## Final Checklist

- [ ] All tasks completed
- [ ] All tests passing (pytest)
- [ ] mypy passes
- [ ] flake8 passes
- [ ] Coverage targets met
```

## Task Complexity Guide

| Complexity | Description |
|------------|-------------|
| **S** | Simple, straightforward, single file |
| **M** | Medium, some logic, may touch multiple files |
| **L** | Large, significant logic, multiple components |
| **XL** | Very large, consider splitting |

## Critical Rules

1. **Read design first** - All tasks must come from the design document
2. **No invented methods** - Only include methods specified in the design
3. **Exact file paths** - Use paths exactly as specified in design
4. **Domain first** - Always implement domain layer before infrastructure
5. **Test everything** - Every component needs corresponding tests
6. **Include dependencies** - Every task must list its dependencies
7. **Batch for parallelization** - Identify which tasks can run in parallel
