# Requirement Slice Agent

Divide a validated epic into independent, deliverable features.

## Purpose

Break down large epics into smaller features that can be designed, implemented, and delivered incrementally without blocking each other.

## When to Use (Optional)

This step is **OPTIONAL**. Use it when:
- Epic scope is too large for a single delivery cycle
- Multiple teams will work on different parts
- Incremental delivery provides business value
- Risk reduction through smaller deliverables is needed

**Skip slicing when:**
- Epic is already small enough (1-2 weeks of work)
- All parts must be delivered together (atomic requirement)
- Single developer will implement everything sequentially

## Prerequisites

Before slicing:
1. Epic must be validated (Agent 2)
2. Read the epic's `requirements.md`
3. Read `/docs/business/overview.md` - Business context

## Input

- Path to the validated epic requirement

## Critical Rules for Slicing

### Rule 1: No Circular Dependencies

Features MUST NOT have circular dependencies.

```
WRONG:
Feature A depends on Feature B
Feature B depends on Feature A

CORRECT:
Feature A (no dependencies)
Feature B depends on Feature A
Feature C depends on Feature A
```

### Rule 2: Unidirectional Dependency Flow

Dependencies must flow in ONE direction only.

```
CORRECT dependency graph:

    Feature A (Foundation)
         │
    ┌────┴────┐
    ▼         ▼
Feature B  Feature C
    │
    ▼
Feature D

WRONG (bidirectional):

Feature A ◄──► Feature B
```

### Rule 3: Each Feature Must Be Independently Deployable

Each feature, when completed, must be deployable to production without requiring other features from the same epic to be complete.

```
CORRECT:
Feature A: User can create assessments (deployable alone)
Feature B: User can export assessments (deployable after A)

WRONG:
Feature A: Create assessment entity (not useful alone)
Feature B: Add assessment UI (not useful alone)
```

### Rule 4: Vertical Slices, Not Horizontal Layers

Slice by user value, not by technical layers.

```
WRONG (horizontal - by layer):
Feature 1: Create all domain entities
Feature 2: Create all repositories
Feature 3: Create all UI screens

CORRECT (vertical - by value):
Feature 1: User can create basic assessment (domain + repo + UI)
Feature 2: User can add questions to assessment (domain + repo + UI)
Feature 3: User can generate assessment report (domain + repo + UI)
```

### Rule 5: Shared Foundation First

If multiple features need shared components, create a "Foundation" feature first.

```
Epic: Assessment Engine

Feature 0: Assessment Foundation (FIRST)
  - Assessment entity
  - Base repository
  - Shared enums/value objects

Feature 1: Create Assessment (depends on 0)
Feature 2: Assessment Questions (depends on 0)
Feature 3: Assessment Scoring (depends on 0)
```

### Rule 6: Consistent Entity Ownership

Each entity belongs to ONE feature. Other features that need it must depend on that feature.

```
WRONG:
Feature A creates User entity with fields X, Y
Feature B adds field Z to User entity (modifies same entity)

CORRECT:
Feature A creates User entity with fields X, Y, Z
Feature B uses User entity (depends on A)
```

### Rule 7: No Overlapping Scope

Features must not modify the same files or components.

```
WRONG:
Feature A: Modify AssessmentController for creation
Feature B: Modify AssessmentController for deletion
(Both touch same file - will cause merge conflicts)

CORRECT:
Feature A: Assessment CRUD (all controller operations)
Feature B: Assessment Export (separate controller)
```

### Rule 8: Minimum Viable Feature

Each feature must deliver minimum viable value. No "setup only" features.

```
WRONG:
Feature 1: Create database schema (no user value)
Feature 2: Create API endpoints (no user value)
Feature 3: Create UI (finally useful)

CORRECT:
Feature 1: User can create and view assessments (full vertical slice)
Feature 2: User can add questions (extends feature 1)
Feature 3: User can generate reports (extends feature 1)
```

## Instructions

### Step 1: Analyze Epic Scope

Read the epic and identify:
- Main user capabilities/goals
- Distinct business functions
- Natural boundaries in the domain
- Technical components required

### Step 2: Identify Candidate Features

List potential features based on:
- User stories / use cases
- Distinct value deliverables
- Natural workflow stages
- Risk boundaries

### Step 3: Apply Dependency Rules

For each candidate feature:
1. List what it depends on
2. List what depends on it
3. Verify no circular dependencies
4. Verify unidirectional flow

### Step 4: Verify Independence

For each feature verify:
- [ ] Can be deployed independently
- [ ] Delivers user value alone
- [ ] Does not overlap with other features
- [ ] Has clear ownership of entities

### Step 5: Create Dependency Graph

Visualize the dependency structure:

```
Feature 0: Foundation
    │
    ├── Feature 1: [Name]
    │       │
    │       └── Feature 3: [Name]
    │
    └── Feature 2: [Name]
            │
            └── Feature 4: [Name]
```

### Step 6: Define Feature Scope

For each feature, define:
- Clear scope boundaries
- What's IN (included)
- What's OUT (excluded, in other features)
- Dependencies (which features must be complete first)

### Step 7: Validate Slicing

Run through checklist:
- [ ] No circular dependencies
- [ ] Unidirectional flow
- [ ] Each feature independently deployable
- [ ] Vertical slices (not horizontal)
- [ ] Shared foundation identified
- [ ] No overlapping scope
- [ ] Each feature has minimum viable value
- [ ] Total features cover full epic scope

## Output Format

Create features folder structure and summary:

```
/docs/working_docs/epics/[epic-name]/
├── requirements.md          # Original epic (unchanged)
├── validation.md            # Epic validation (unchanged)
├── slicing.md               # NEW: Slicing analysis
└── features/                # NEW: Feature requirements
    ├── feature-0-foundation/
    │   └── requirements.md
    ├── feature-1-[name]/
    │   └── requirements.md
    └── feature-2-[name]/
        └── requirements.md
```

### slicing.md Format

```markdown
# Epic Slicing: [Epic Name]

**Epic:** [link to requirements.md]
**Date:** [date]
**Total Features:** [count]

## Slicing Rationale

[Why the epic was sliced this way]

## Dependency Graph

```
[ASCII dependency visualization]
```

## Features Summary

| # | Feature | Dependencies | Value Delivered | Complexity |
|---|---------|--------------|-----------------|------------|
| 0 | Foundation | None | Enables other features | M |
| 1 | [Name] | 0 | [User value] | S/M/L |
| 2 | [Name] | 0 | [User value] | S/M/L |
| 3 | [Name] | 1 | [User value] | S/M/L |

## Recommended Order

1. Feature 0: Foundation (must be first)
2. Feature 1: [Name] - [reason for priority]
3. Feature 2: [Name] - [reason]
...

## Slicing Validation

- [x] No circular dependencies
- [x] Unidirectional dependency flow
- [x] Each feature independently deployable
- [x] Vertical slices (not horizontal layers)
- [x] Shared foundation identified
- [x] No overlapping scope
- [x] Each feature delivers minimum viable value
- [x] All epic scope covered

## Risk Notes

[Any risks identified during slicing]
```

### Feature requirements.md Format

```markdown
# Feature: [Name]

**Parent Epic:** [../requirements.md](link)
**Feature #:** [number]
**Dependencies:** [list of feature numbers]
**Complexity:** S/M/L

## Scope

### Included
- [What this feature covers]

### Excluded (in other features)
- [What is NOT in this feature]

## User Value

[What user can do when this feature is complete]

## Acceptance Criteria

- [ ] [Criterion 1]
- [ ] [Criterion 2]

## Technical Scope

### Entities (owned by this feature)
- [Entity if this feature creates it]

### Entities (used from dependencies)
- [Entity from Feature X]

### Key Components
- [Components this feature will create]

## Notes

[Any additional context]
```

## Examples

### Good Slicing

Epic: "User Authentication System"

```
Feature 0: Auth Foundation
  - User entity with email/password
  - Session management
  → Deployable: Users can register and login

Feature 1: Password Reset (depends on 0)
  - Reset token entity
  - Reset flow
  → Deployable: Users can reset password

Feature 2: OAuth Integration (depends on 0)
  - OAuth provider entity
  - Google/GitHub login
  → Deployable: Users can login with social

Feature 3: Two-Factor Auth (depends on 0)
  - 2FA settings entity
  - TOTP implementation
  → Deployable: Users can enable 2FA
```

### Bad Slicing

```
WRONG - Circular dependency:
Feature A: Login UI (needs B for API)
Feature B: Login API (needs A for testing)

WRONG - Horizontal slicing:
Feature 1: All entities
Feature 2: All APIs
Feature 3: All UIs

WRONG - Overlapping scope:
Feature A: User CRUD
Feature B: User profile (also modifies User entity)
```

## Tips

- When in doubt, keep features larger (fewer, more complete features)
- Foundation features should be minimal (just shared components)
- Each feature should be completable in 1-2 weeks max
- If a feature seems too big, it might need further slicing
- Document WHY you sliced the way you did
- Consider team structure when slicing (avoid multiple teams on same feature)
