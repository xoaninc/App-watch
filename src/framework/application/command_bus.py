from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Dict, Type, Any


class Command(ABC):
    """Base class for all commands."""
    pass


TCommand = TypeVar('TCommand', bound=Command)


class CommandHandler(ABC, Generic[TCommand]):
    """Base class for all command handlers."""

    @abstractmethod
    def execute(self, command: TCommand) -> None:
        """Execute the command. Must return None."""
        pass


class CommandBus:
    """Command bus that resolves handlers by convention.

    NOTE: Currently uses handle() method for backwards compatibility.
    TODO: Migrate all handlers to use execute() -> None pattern.
    """

    def __init__(self, container: Any) -> None:
        """Initialize CommandBus with container dependency.

        Args:
            container: Container instance for resolving handlers.
        """
        self.container = container
        self._handlers_cache: Dict[Type[Command], Any] = {}

    def dispatch(self, command: Command) -> Any:
        """Dispatch a command to its handler.

        NOTE: Currently returns result for backwards compatibility.
        TODO: Change to return None once handlers are migrated.
        """
        result, _ = self._dispatch_internal(command)
        return result

    def dispatch_with_events(self, command: Command) -> tuple[Any, list]:
        """Dispatch a command and return both result and domain events.

        Returns:
            Tuple of (result, events) where events is a list of domain events
            generated by the handler.
        """
        return self._dispatch_internal(command)

    def _dispatch_internal(self, command: Command) -> tuple[Any, list]:
        """Internal dispatch that returns result and events."""
        command_type = type(command)

        # Cache handler to avoid repeated lookups
        if command_type in self._handlers_cache:
            handler_instance = self._handlers_cache[command_type]()
        else:
            # Find handler by convention: RegisterOrganizationCommand -> register_organization_command_handler
            handler_name = f"{command_type.__name__}Handler"
            handler_provider_name = self._camel_to_snake(handler_name)

            handler_provider = getattr(self.container, handler_provider_name)
            self._handlers_cache[command_type] = handler_provider
            handler_instance = handler_provider()

        # Execute command
        result = handler_instance.handle(command)

        # Get pending events if handler supports it
        events = []
        if hasattr(handler_instance, 'get_pending_events'):
            events = handler_instance.get_pending_events()

        return result, events

    def execute(self, command: Command) -> Any:
        """Alias for dispatch method."""
        return self.dispatch(command)

    @staticmethod
    def _camel_to_snake(name: str) -> str:
        """Convert CamelCase to snake_case."""
        import re
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
